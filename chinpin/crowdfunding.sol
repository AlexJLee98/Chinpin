pragma solidity ^0.4.24;

  /** @dev Import the token contract. */
contract Token {
    function mintTokens (uint256, string, string) public pure {}
    function _transfer (address, address, uint256) private pure returns (bool) {}
    function transfer (address , uint256) public pure {}
    function transferFrom(address, address, uint256) public pure {}
    function allowance(address, address) public pure {}
}

/** @title Create and execute a crowdsale. */
contract Crowdsale {
     
     event eventCreated (address creator, uint256 eventID);
     event eventStarted (uint256 eventID);
     event investmentSent (address investor, uint256 eventID);
     event eventFinished (uint256 eventID);
     
     /** @dev Import the token contract. */
    Token token;
    
    function existingToken (address _tokenAddress) public {
        token = Token(_tokenAddress);
    }
    
    uint256 dummyId;
    
    /** @dev This is an unique event ID that each crowdsale event has. The event ID allows us to differentiate between different events. */ 
    uint256 eventID;
    
    /** @dev The contract address will recieve the ether from the crowdfunding events. */
    address contractAddress;
    
    /** @dev This is the struct we use to create an event.
      * @param creator            The creator of the event
      * @param storeKeys          Stores the keys of all investors for an event
      * @param amountRaised       The current amount raised in an event
      * @param fundingGoal        The funding goal for an event
      * @param eventStart         When an event will start
      * @param eventEnd           When an event will end
      * @param eventDuration      How long an event will last
      * @param eventID            The unique eventID of an event
      * @param description        A brief description of an event
      * @param eventLive          Tells us whether the event is currently live
      * @param eventDuration      How much longer an event will last
      * @param continueAfterGoal  If an event will continue to accept investments if it                                   exceeds the goal 
      * @param distributeTokens   Tells us whether the event has distributed asset tokens
      * @param refundEther        Tells us whether the event has refunded ether
      */
    struct Event {
        address creator;
        address[] storeKeys;
        
        uint256 amountRaised;
        uint256 fundingGoal;
        uint256 eventStart;
        uint256 eventEnd;
        uint256 eventDuration;
        uint256 eventID;
        
        string description;
        
        bool eventLive;
        bool fundingGoalReached;
        bool continueAfterGoal;
        bool distributeTokens;
        bool refundEther;
    }
    
    /** @dev This is the struct that stores an investor's data for all events. We will create an array of struct for each investor in which each investment that an investor makes is represented by one index of an InvestorData struct. 
      * @param investorKey            The investor's address
      * @param amountContributed      The amount that they invested
      * @param timeOfContribution     The time of the investment
      * @param timeOfRefund           The time of the refund
      * @param bool refunded          Whether they have been refunded or not
      */
    struct InvestorData {
        address investorKey;
        uint256 amountContributed;
        uint256 timeOfContribution; 
        uint256 timeOfRefund;
        bool refunded;
        bool recieveToken;
    }    
    
    /** @dev This mapping maps an eventID to an event. 
      * @param uint256 The eventID 
      * @param Event   The event that the mapping will map the event ID to
      */
    mapping(uint256 => Event) eventMap;
    
    /** @dev This mapping maps an eventID to a mapping of an investor's key to that investor's data.
      * @param uint256         The eventID
      * @param address         The investor's key
      * @param InvestorData[]  The investor data array that the investor's key is mapped to
      */
    mapping(uint256 => mapping(address => InvestorData[])) investorMap;
    
    /** This mapping maps an eventID to a mapping of an investor's key to the amount of ether to send.
      * @param uint256  The eventID
      * @param address  Address that accepts ether
      * @param uint256  Num ether to send
      */
    mapping(uint256 => mapping(address => uint256)) balance;
    
    /** @dev This function is made for creating and initializing an event. The eventID of the event ID is generated by incrementing the eventID counter by 1 (starts at 0). The event will not be started until you manually do so.
      * @param _fundingGoal        The fundraising goal of the event in ether
      * @param _eventDuration      How long the event will last (in minutes)
      * @param _description        A brief description of the event
      * @param _continueAfterGoal  Continue accepting ether after surpassing funding goal 
      */
    function createEvent (uint256 _fundingGoal, uint256 _eventDuration, string _description, bool _continueAfterGoal) public returns (bool success)  {
        Event memory myEvent;
        myEvent.creator = msg.sender;
        myEvent.fundingGoal = _fundingGoal * 1000000000000000000;
        myEvent.eventDuration = _eventDuration * 60;
        eventID += 1;
        myEvent.eventID = eventID;
        myEvent.description = _description;
        myEvent.continueAfterGoal = _continueAfterGoal;
        myEvent.eventLive = false;
        eventMap[myEvent.eventID] = myEvent;
        emit eventCreated(myEvent.creator, myEvent.eventID);
        return true;
    }
    
    /** @dev This function is made for starting an event. It does not allow you to restart an event that has ended.
      * @param _eventID The eventID of the event you want to start.
      */
    function startEvent (uint256 _eventID) public {
        require(msg.sender == eventMap[_eventID].creator);
        require(_eventID <= eventID);
        require(eventMap[_eventID].eventEnd == 0);
        eventMap[_eventID].eventStart = now;
        eventMap[_eventID].eventEnd = now + eventMap[_eventID].eventDuration;
        eventMap[_eventID].eventLive = true;
        emit eventStarted(_eventID);
    }
    
    /** @dev This function is made for ending an event.
      * @param _eventID The eventID of the event you want to end.
      */
    function endEvent (uint256 _eventID) public {
        //require(msg.sender == eventMap[_eventID].creator);
        eventMap[_eventID].eventEnd = now;
        eventMap[_eventID].eventLive = false;
        emit eventFinished(_eventID);
    }
    
    function eventData(uint256 _eventID) public view returns (uint256 __eventID, string _description, address eventCreator, bool _continueAfterGoal, bool _eventLive, uint256 contractBalance) {
        return (eventMap[_eventID].eventID, eventMap[_eventID].description, eventMap[_eventID].creator, eventMap[_eventID].continueAfterGoal, eventMap[_eventID].eventLive, address(this).balance);
    }
    
    function eventInvestmentData(uint256 _eventID) public view returns (uint256 _eventStart, uint256 _eventEnd, uint256 currentTime, uint256 _amountRaised, uint256 _fundingGoal, uint256 _numInvestors, bool _eventLive) {
        return (eventMap[_eventID].eventStart, eventMap[_eventID].eventEnd, now, eventMap[_eventID].amountRaised, eventMap[_eventID].fundingGoal, eventMap[_eventID].storeKeys.length, eventMap[_eventID].eventLive);
    }
    
    /** @dev This function is for mapping an investor's data to the correct event and mapping their key to their InvestorData array. The function is called whenever someone invests.
      * @param _eventID             The eventID that the investor pledged to
      * @param _investorKey         The investor's address
      * @param _amountContributed   Amount that they contributed
      * @param _timeOfContribution  The time of the contribution
      */
    function map (uint256 _eventID, address _investorKey, uint256 _amountContributed, uint256 _timeOfContribution) private  {
        InvestorData memory user;
        user.investorKey = _investorKey;
        user.amountContributed = _amountContributed;
        user.timeOfContribution = _timeOfContribution;
        user.refunded = false;
        user.recieveToken = false;
        investorMap[_eventID][_investorKey].push(user);
    }
     
    /** @dev This function is for allowing an investor to pledge money to a particular crowdfunding event which is denoted by the eventID.
      * @param _eventID  The eventID that the investor wants to pledge to
     */
    function sendInvestment (uint256 _eventID) payable public {
        if (now >= eventMap[_eventID].eventEnd) {
            if (eventMap[_eventID].amountRaised >= eventMap[_eventID].fundingGoal) {
                eventMap[_eventID].fundingGoalReached = true;
                eventMap[_eventID].distributeTokens = true;
                endEvent(_eventID);
                emit eventFinished(_eventID);
            } else {
                endEvent(_eventID);
                eventMap[_eventID].refundEther = true;
                emit eventFinished(_eventID);
            }
            balance[_eventID][msg.sender] -= msg.value;
            msg.sender.transfer(msg.value);
            return;
        }
        require(eventMap[_eventID].eventLive);
        eventMap[_eventID].amountRaised += msg.value; 
        balance[_eventID][contractAddress] += msg.value;
        emit investmentSent(msg.sender, _eventID);
        if (investorMap[_eventID][msg.sender].length == 0) {
            eventMap[_eventID].storeKeys.push(msg.sender);
        }
        map(_eventID, msg.sender, msg.value, now);
        if (eventMap[_eventID].amountRaised >= eventMap[_eventID].fundingGoal && eventMap[_eventID].continueAfterGoal == false) {
            endEvent(_eventID);
            eventMap[_eventID].fundingGoalReached = true;
            eventMap[_eventID].distributeTokens = true;
            emit eventFinished(_eventID);
        }
    }
    
    /** Display a investor's data (singular investment) for a particular event */
    function investorData (uint256 _eventID, uint256 numInvestor, uint256 numInvestment) public view returns (address _investorKey, uint256 _investorContribution, uint256 _timeOfContribution) {
        address _investor = eventMap[_eventID].storeKeys[numInvestor];
        return (_investor, investorMap[_eventID][_investor][numInvestment].amountContributed, investorMap[_eventID][_investor][numInvestment].timeOfContribution);
    }
    
    function investorReturnData (uint256 _eventID, uint256 numInvestor, uint256 numInvestment) public view returns  (address _investorKey, bool refunded, uint256 timeOfRefund, bool recieveToken) {
        address _investor = eventMap[_eventID].storeKeys[numInvestor];
        return (_investor, investorMap[_eventID][_investor][numInvestment].refunded, investorMap[_eventID][_investor][numInvestment].timeOfRefund, investorMap[_eventID][_investor][numInvestment].recieveToken);
    }
    
    function mintToken (uint256 _eventID, string tokenName, string tokenSymbol) public {
         require(msg.sender == eventMap[_eventID].creator);
         require(eventMap[_eventID].distributeTokens);
         dummyId++;
         token.mintTokens(eventMap[_eventID].amountRaised, tokenName, tokenSymbol);
    }
    
    function withdrawAssetTokens(uint256 _eventID) public {
        uint256 _numTokens;
        
        require(eventMap[_eventID].distributeTokens);
        require(investorMap[_eventID][msg.sender][0].recieveToken == false);
        for (uint256 i = 0; i < investorMap[_eventID][msg.sender].length; i++) {
            _numTokens += investorMap[_eventID][msg.sender][i].amountContributed;
            investorMap[_eventID][msg.sender][i].recieveToken = true;
        }
        token.transfer(msg.sender, _numTokens);
    }
    
    function refundEther (uint256 _eventID) public {
        uint256 _investment;
        
        require(eventMap[_eventID].refundEther);
        require (investorMap[_eventID][msg.sender][0].refunded == false);
        for (uint i = 0; i < investorMap[_eventID][msg.sender].length; i++) {
            _investment += investorMap[_eventID][msg.sender][i].amountContributed; 
            investorMap[_eventID][msg.sender][i].timeOfRefund = now;
            investorMap[_eventID][msg.sender][i].refunded = true;
        }
        balance[_eventID][msg.sender] -= _investment;
        msg.sender.transfer(_investment);
    }
}

